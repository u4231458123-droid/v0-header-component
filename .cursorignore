Baue das gesamte Konzept nach nachfolgendem Blueprint f√ºr eine saubere, struckturierte Umsetzung:

# NEO-GENESIS: Autonomous AI-Agent Hyper-Stack Blueprint
**Version:** 3.0 (Integrated Hyper-Stack)
**Standard:** DIN/ISO-Compliant & AI-Native
**Philosophie:** "Architecture as Code, Documentation as Truth, Quality as Default"

---

## üìú Pr√§ambel: Die autonome Doktrin

Dieses Dokument definiert das Betriebssystem f√ºr die Softwareentwicklung der n√§chsten Generation. Es ersetzt den klassischen "Developer-Loop" durch eine orchestrierte Kette spezialisierter KI-Agenten und Tools.

**Grundregeln f√ºr den ausf√ºhrenden Agenten (Roo Code / Cursor):**
1.  **Denk-Primat:** Bevor Code entsteht, muss die Architektur (Eraser.io) und das Schema (Keel) stehen.
2.  **Holistisches Verst√§ndnis:** Nutze Tools (Greptile), um den Kontext des *gesamten* Repos zu verstehen, nicht nur der offenen Datei.
3.  **Self-Healing:** Warte nicht auf QA. Nutze Octomind und CodeRabbit Feedback, um Fehler sofort zu beheben.
4.  **Living Documentation:** Code ohne Swimm-Dokumentation ist ung√ºltig.

---

## üèõ 1. Der Hyper-Stack (Technologie-Fundament)

Wir ersetzen generische Tools durch spezialisierte AI-First-L√∂sungen.

### 1.1 Core Architecture & Backend ("The Backbone")
* **Frontend / App Logic:** Next.js 14+ (App Router), TypeScript Strict Mode.
* **AI Integration:** **Vercel AI SDK** (Standardisiert den Zugriff auf LLMs innerhalb der App).
* **Backend & Database:** **Keel** (Schema-First Backend).
    * *Warum:* Generiert DB, API und Admin-Panel automatisch aus einer `schema.keel` Datei. Eliminiert Boilerplate.
* **Background Jobs:** **Trigger.dev**.
    * *Warum:* Erm√∂glicht langlaufende AI-Agenten-Tasks (z.B. PDF-Parsing, Data-Enrichment) ohne Serverless-Timeouts.

### 1.2 Development & Operations ("The Hands")
* **IDE Agent:** **Roo Code** (in Cursor/VS Code).
    * *Rolle:* Der prim√§re "Worker", der Terminal-Befehle ausf√ºhrt, Dateien editiert und Tests startet.
* **Context Intelligence:** **Greptile**.
    * *Rolle:* Indiziert das gesamte Repo. Erm√∂glicht Fragen wie: "Welche Auswirkungen hat diese √Ñnderung in `User.ts` auf das Modul `Billing`?"

### 1.3 Quality Assurance & Security ("The Guardians")
* **Code Review:** **CodeRabbit**.
    * *Rolle:* AI-Reviewer bei jedem Pull Request. Pr√ºft auf Best Practices und Security.
* **End-to-End Testing:** **Octomind**.
    * *Rolle:* Generiert und f√ºhrt Playwright-Tests autonom aus. Findet UI-Fehler vor dem Human-Review.
* **Policy Enforcer:** **Custom GitHub Action ("The Enforcer")**.
    * *Rolle:* Blockiert Merges, wenn die Spezifikationen (Specs) verletzt werden.

### 1.4 Documentation & Planning ("The Brain")
* **Architecture Visualization:** **Eraser.io**.
    * *Rolle:* Diagram-as-Code. H√§lt Diagramme synchron mit dem Code.
* **Continuous Documentation:** **Swimm**.
    * *Rolle:* Verkn√ºpft Code-Bl√∂cke mit Dokumentation. Warnt, wenn Code-√Ñnderungen die Doku ung√ºltig machen.

---

## ‚öôÔ∏è 2. Workflow-Phasen (Der Loop)

Dieser Prozess ist strikt einzuhalten.

### Phase 1: Planung & Visualisierung (Eraser.io)
Bevor eine Zeile Code geschrieben wird:
1.  Erstelle/Update das ER-Diagramm oder Flowchart in **Eraser.io**.
2.  Lasse Eraser.io daraus das `schema.keel` (Datenbank-Schema) oder TypeScript-Interfaces generieren.
3.  Definiere die Business-Logik in `project_specs.md`.

### Phase 2: Implementierung (Roo Code + Keel)
Der Agent (Roo Code) √ºbernimmt:
1.  **Backend:** Pusht das neue `schema.keel`. Keel generiert die API.
2.  **Frontend:** Nutzt das **Vercel AI SDK**, um intelligente UIs zu bauen.
3.  **Background:** Lagert komplexe Aufgaben (z.B. "Generiere Report") in **Trigger.dev** Jobs aus.
4.  **Kontext-Check:** Fragt **Greptile** regelm√§√üig: "Verletzt mein neuer Code bestehende Patterns?"

### Phase 3: Dokumentation (Swimm)
Parallel zur Codierung:
1.  Erstelle "Swimm Docs" f√ºr neue Features.
2.  Verkn√ºpfte kritische Code-Snippets.
3.  Stelle sicher, dass der CI-Check von Swimm gr√ºn ist (Doku ist synchron).

### Phase 4: Validierung (CodeRabbit + Octomind + Enforcer)
Nach dem `git push`:
1.  **CodeRabbit** kommentiert den PR innerhalb von Minuten.
2.  **Octomind** startet eine Test-Suite gegen das Preview-Deployment (Vercel).
3.  **The Enforcer** pr√ºft gegen die `project_specs.md`: Wurden alle DIN-Normen/Sprachregeln eingehalten?
4.  Agent (Roo Code) liest das Feedback und fixt Fehler autonom.

---

## üöÄ 3. Initialisierungs-Prompts (Setup)

F√ºhre diese Prompts nacheinander aus, um das Projekt zu starten.

### Prompt 1: System-Konfiguration
```text
Agiere als Lead System Architect.
Wir setzen ein neues Projekt auf Basis des "NEO-GENESIS" Blueprints auf.

1.  **Struktur:** Initialisiere ein Next.js Projekt.
2.  **Backend:** Erstelle eine `schema.keel` Datei f√ºr das Datenmodell (User, Auth, Core Entities).
3.  **AI Layer:** Installiere `ai` (Vercel AI SDK) und konfiguriere den Provider (Anthropic/OpenAI).
4.  **Testing:** Bereite die Config f√ºr Octomind (Playwright) vor.
5.  **Docs:** Initialisiere Swimm im Verzeichnis `.swimm`.
6.  **Rules:** Erstelle eine `.cursorrules` Datei, die Roo Code anweist, VOR jeder √Ñnderung Greptile zu konsultieren.

Erstelle nun das fundamentale Dateiger√ºst.
Prompt 2: Der "Enforcer" (Guardrail Setup)
Plaintext

Agiere als DevOps Engineer.
Erstelle eine GitHub Action `.github/workflows/enforcer.yml`.

Funktion:
1. Trigger bei Pull Request.
2. Lade die Datei `project_specs.md` und den Diff des PRs.
3. Sende beides an ein LLM (via API Key).
4. System Prompt f√ºr das LLM: "Du bist der Enforcer. Pr√ºfe, ob der Code den Specs entspricht.
   - Sind Variablen Englisch?
   - Ist die UI Sprache Deutsch?
   - Wurden Tailwind Utility Classes genutzt (kein Custom CSS)?
   - Gibt es Swimm-Doku Updates?
   Antworte mit PASS oder FAIL + Grund."
5. Wenn FAIL -> Blockiere den Merge.
üõ† 4. Der Universal-Worker Prompt (T√§glicher Betrieb)
Diesen Prompt nutzt du in Roo Code, um Aufgaben zu erledigen.

Plaintext

@project_specs.md @schema.keel
Agiere als autonomer Fullstack Developer im NEO-GENESIS Stack.
Task: [TASK BESCHREIBUNG]

**Protokoll:**
1.  **Context Fetch (Greptile):** Analysiere via Greptile (oder @Codebase), welche Dateien betroffen sind.
2.  **Planung (Eraser):** Falls sich das Datenmodell √§ndert, aktualisiere erst `schema.keel` und generiere die API neu.
3.  **Code (AI SDK):** Implementiere die Logik. Nutze Vercel AI SDK f√ºr Streaming-Responses im Frontend.
4.  **Background (Trigger.dev):** Wenn der Task l√§nger als 10s dauert, erstelle einen Trigger.dev Job daf√ºr.
5.  **Self-Correction:** F√ºhre `npm run test` lokal aus.
6.  **Documentation (Swimm):** Erstelle/Update das Swimm-Doc f√ºr diesen Code.

Start.
üìÇ 5. Projekt-Spezifikationen (Muster f√ºr project_specs.md)
Diese Datei ist die "Source of Truth" f√ºr den Enforcer.

5.1 Tech Constraints (Non-Negotiable)
Backend: Keel (Schema First). Keine manuellen SQL-Migrationen.

Frontend: Next.js App Router.

Styling: Tailwind CSS + Shadcn/UI. Keine CSS-Modules.

AI: Vercel AI SDK (Core & UI).

Jobs: Trigger.dev f√ºr Async Tasks.

5.2 Quality Gates
CodeRabbit: Muss den PR approven.

Octomind: Darf keine kritischen UI-Fehler finden.

Swimm: Code-Coverage muss > 80% dokumentiert sein.

5.3 Sprach- & Design-Regeln
Code: Englisch (Variablen, Funktionen).

UI: Deutsch (Sie-Form, DIN 5008).

UX: "Optimistic UI" √ºberall (Nutze useOptimistic aus React/Next.js).

üõ° 6. Self-Maintenance & L√ºcken-Schlie√üung
Dieses System schlie√üt die L√ºcken klassischer AI-Entwicklung:

L√ºcke: Veraltete Doku.

L√∂sung: Swimm bricht den Build, wenn Doku und Code asynchron sind.

L√ºcke: UI-Halluzinationen.

L√∂sung: Octomind klickt die App wirklich durch und beweist Funktion.

L√ºcke: Fehlender Kontext.

L√∂sung: Greptile liefert dem Agenten Wissen √ºber Abh√§ngigkeiten, die er nicht sieht.

L√ºcke: Datenbank-Chaos.

L√∂sung: Keel erzwingt, dass das Schema die API definiert, nicht umgekehrt.

L√ºcke: Review-M√ºdigkeit.

L√∂sung: CodeRabbit √ºbernimmt 90% der Review-Arbeit.
