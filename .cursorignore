Baue das gesamte Konzept nach nachfolgendem Blueprint fÃ¼r eine saubere, struckturierte Umsetzung:

# NEO-GENESIS: Autonomous AI-Agent Hyper-Stack Blueprint
**Version:** 3.0 (Integrated Hyper-Stack)
**Standard:** DIN/ISO-Compliant & AI-Native
**Philosophie:** "Architecture as Code, Documentation as Truth, Quality as Default"

---

## ğŸ“œ PrÃ¤ambel: Die autonome Doktrin

Dieses Dokument definiert das Betriebssystem fÃ¼r die Softwareentwicklung der nÃ¤chsten Generation. Es ersetzt den klassischen "Developer-Loop" durch eine orchestrierte Kette spezialisierter KI-Agenten und Tools.

**Grundregeln fÃ¼r den ausfÃ¼hrenden Agenten (Roo Code / Cursor):**
1.  **Denk-Primat:** Bevor Code entsteht, muss die Architektur (Eraser.io) und das Schema (Keel) stehen.
2.  **Holistisches VerstÃ¤ndnis:** Nutze Tools (Greptile), um den Kontext des *gesamten* Repos zu verstehen, nicht nur der offenen Datei.
3.  **Self-Healing:** Warte nicht auf QA. Nutze Octomind und CodeRabbit Feedback, um Fehler sofort zu beheben.
4.  **Living Documentation:** Code ohne Swimm-Dokumentation ist ungÃ¼ltig.

---

## ğŸ› 1. Der Hyper-Stack (Technologie-Fundament)

Wir ersetzen generische Tools durch spezialisierte AI-First-LÃ¶sungen.

### 1.1 Core Architecture & Backend ("The Backbone")
* **Frontend / App Logic:** Next.js 14+ (App Router), TypeScript Strict Mode.
* **AI Integration:** **Vercel AI SDK** (Standardisiert den Zugriff auf LLMs innerhalb der App).
* **Backend & Database:** **Keel** (Schema-First Backend).
    * *Warum:* Generiert DB, API und Admin-Panel automatisch aus einer `schema.keel` Datei. Eliminiert Boilerplate.
* **Background Jobs:** **Trigger.dev**.
    * *Warum:* ErmÃ¶glicht langlaufende AI-Agenten-Tasks (z.B. PDF-Parsing, Data-Enrichment) ohne Serverless-Timeouts.

### 1.2 Development & Operations ("The Hands")
* **IDE Agent:** **Roo Code** (in Cursor/VS Code).
    * *Rolle:* Der primÃ¤re "Worker", der Terminal-Befehle ausfÃ¼hrt, Dateien editiert und Tests startet.
* **Context Intelligence:** **Greptile**.
    * *Rolle:* Indiziert das gesamte Repo. ErmÃ¶glicht Fragen wie: "Welche Auswirkungen hat diese Ã„nderung in `User.ts` auf das Modul `Billing`?"

### 1.3 Quality Assurance & Security ("The Guardians")
* **Code Review:** **CodeRabbit**.
    * *Rolle:* AI-Reviewer bei jedem Pull Request. PrÃ¼ft auf Best Practices und Security.
* **End-to-End Testing:** **Octomind**.
    * *Rolle:* Generiert und fÃ¼hrt Playwright-Tests autonom aus. Findet UI-Fehler vor dem Human-Review.
* **Policy Enforcer:** **Custom GitHub Action ("The Enforcer")**.
    * *Rolle:* Blockiert Merges, wenn die Spezifikationen (Specs) verletzt werden.

### 1.4 Documentation & Planning ("The Brain")
* **Architecture Visualization:** **Eraser.io**.
    * *Rolle:* Diagram-as-Code. HÃ¤lt Diagramme synchron mit dem Code.
* **Continuous Documentation:** **Swimm**.
    * *Rolle:* VerknÃ¼pft Code-BlÃ¶cke mit Dokumentation. Warnt, wenn Code-Ã„nderungen die Doku ungÃ¼ltig machen.

---

## âš™ï¸ 2. Workflow-Phasen (Der Loop)

Dieser Prozess ist strikt einzuhalten.

### Phase 1: Planung & Visualisierung (Eraser.io)
Bevor eine Zeile Code geschrieben wird:
1.  Erstelle/Update das ER-Diagramm oder Flowchart in **Eraser.io**.
2.  Lasse Eraser.io daraus das `schema.keel` (Datenbank-Schema) oder TypeScript-Interfaces generieren.
3.  Definiere die Business-Logik in `project_specs.md`.

### Phase 2: Implementierung (Roo Code + Keel)
Der Agent (Roo Code) Ã¼bernimmt:
1.  **Backend:** Pusht das neue `schema.keel`. Keel generiert die API.
2.  **Frontend:** Nutzt das **Vercel AI SDK**, um intelligente UIs zu bauen.
3.  **Background:** Lagert komplexe Aufgaben (z.B. "Generiere Report") in **Trigger.dev** Jobs aus.
4.  **Kontext-Check:** Fragt **Greptile** regelmÃ¤ÃŸig: "Verletzt mein neuer Code bestehende Patterns?"

### Phase 3: Dokumentation (Swimm)
Parallel zur Codierung:
1.  Erstelle "Swimm Docs" fÃ¼r neue Features.
2.  VerknÃ¼pfte kritische Code-Snippets.
3.  Stelle sicher, dass der CI-Check von Swimm grÃ¼n ist (Doku ist synchron).

### Phase 4: Validierung (CodeRabbit + Octomind + Enforcer)
Nach dem `git push`:
1.  **CodeRabbit** kommentiert den PR innerhalb von Minuten.
2.  **Octomind** startet eine Test-Suite gegen das Preview-Deployment (Vercel).
3.  **The Enforcer** prÃ¼ft gegen die `project_specs.md`: Wurden alle DIN-Normen/Sprachregeln eingehalten?
4.  Agent (Roo Code) liest das Feedback und fixt Fehler autonom.

---

## ğŸš€ 3. Initialisierungs-Prompts (Setup)

FÃ¼hre diese Prompts nacheinander aus, um das Projekt zu starten.

### Prompt 1: System-Konfiguration
```text
Agiere als Lead System Architect.
Wir setzen ein neues Projekt auf Basis des "NEO-GENESIS" Blueprints auf.

1.  **Struktur:** Initialisiere ein Next.js Projekt.
2.  **Backend:** Erstelle eine `schema.keel` Datei fÃ¼r das Datenmodell (User, Auth, Core Entities).
3.  **AI Layer:** Installiere `ai` (Vercel AI SDK) und konfiguriere den Provider (Anthropic/OpenAI).
4.  **Testing:** Bereite die Config fÃ¼r Octomind (Playwright) vor.
5.  **Docs:** Initialisiere Swimm im Verzeichnis `.swimm`.
6.  **Rules:** Erstelle eine `.cursorrules` Datei, die Roo Code anweist, VOR jeder Ã„nderung Greptile zu konsultieren.

Erstelle nun das fundamentale DateigerÃ¼st.
Prompt 2: Der "Enforcer" (Guardrail Setup)
Plaintext

Agiere als DevOps Engineer.
Erstelle eine GitHub Action `.github/workflows/enforcer.yml`.

Funktion:
1. Trigger bei Pull Request.
2. Lade die Datei `project_specs.md` und den Diff des PRs.
3. Sende beides an ein LLM (via API Key).
4. System Prompt fÃ¼r das LLM: "Du bist der Enforcer. PrÃ¼fe, ob der Code den Specs entspricht.
   - Sind Variablen Englisch?
   - Ist die UI Sprache Deutsch?
   - Wurden Tailwind Utility Classes genutzt (kein Custom CSS)?
   - Gibt es Swimm-Doku Updates?
   Antworte mit PASS oder FAIL + Grund."
5. Wenn FAIL -> Blockiere den Merge.
ğŸ›  4. Der Universal-Worker Prompt (TÃ¤glicher Betrieb)
Diesen Prompt nutzt du in Roo Code, um Aufgaben zu erledigen.

Plaintext

@project_specs.md @schema.keel
Agiere als autonomer Fullstack Developer im NEO-GENESIS Stack.
Task: [TASK BESCHREIBUNG]

**Protokoll:**
1.  **Context Fetch (Greptile):** Analysiere via Greptile (oder @Codebase), welche Dateien betroffen sind.
2.  **Planung (Eraser):** Falls sich das Datenmodell Ã¤ndert, aktualisiere erst `schema.keel` und generiere die API neu.
3.  **Code (AI SDK):** Implementiere die Logik. Nutze Vercel AI SDK fÃ¼r Streaming-Responses im Frontend.
4.  **Background (Trigger.dev):** Wenn der Task lÃ¤nger als 10s dauert, erstelle einen Trigger.dev Job dafÃ¼r.
5.  **Self-Correction:** FÃ¼hre `npm run test` lokal aus.
6.  **Documentation (Swimm):** Erstelle/Update das Swimm-Doc fÃ¼r diesen Code.

Start.
ğŸ“‚ 5. Projekt-Spezifikationen (Muster fÃ¼r project_specs.md)
Diese Datei ist die "Source of Truth" fÃ¼r den Enforcer.

5.1 Tech Constraints (Non-Negotiable)
Backend: Keel (Schema First). Keine manuellen SQL-Migrationen.

Frontend: Next.js App Router.

Styling: Tailwind CSS + Shadcn/UI. Keine CSS-Modules.

AI: Vercel AI SDK (Core & UI).

Jobs: Trigger.dev fÃ¼r Async Tasks.

5.2 Quality Gates
CodeRabbit: Muss den PR approven.

Octomind: Darf keine kritischen UI-Fehler finden.

Swimm: Code-Coverage muss > 80% dokumentiert sein.

5.3 Sprach- & Design-Regeln
Code: Englisch (Variablen, Funktionen).

UI: Deutsch (Sie-Form, DIN 5008).

UX: "Optimistic UI" Ã¼berall (Nutze useOptimistic aus React/Next.js).

ğŸ›¡ 6. Self-Maintenance & LÃ¼cken-SchlieÃŸung
Dieses System schlieÃŸt die LÃ¼cken klassischer AI-Entwicklung:

LÃ¼cke: Veraltete Doku.

LÃ¶sung: Swimm bricht den Build, wenn Doku und Code asynchron sind.

LÃ¼cke: UI-Halluzinationen.

LÃ¶sung: Octomind klickt die App wirklich durch und beweist Funktion.

LÃ¼cke: Fehlender Kontext.

LÃ¶sung: Greptile liefert dem Agenten Wissen Ã¼ber AbhÃ¤ngigkeiten, die er nicht sieht.

LÃ¼cke: Datenbank-Chaos.

LÃ¶sung: Keel erzwingt, dass das Schema die API definiert, nicht umgekehrt.

LÃ¼cke: Review-MÃ¼digkeit.

LÃ¶sung: CodeRabbit Ã¼bernimmt 90% der Review-Arbeit.



Zudem ist die nachfolgende MCP LÃ¶sung zu integrieren:

The Nexus Bridge (MCP Architecture Standard)Status: Erweiterungs-Modul (Phase 0 Integration)Ziel: Eliminierung von Kontext-Blindheit und Halluzinationen durch direkte API-Anbindung der Entwicklungsumgebung.1. Konzept & PhilosophieIn klassischen Setups muss der AI-Agent (Cursor, Roo Code, Windsurf) Dateien lesen und "raten", wie Datenbank oder Design-System aussehen.The Nexus Bridge ist ein lokaler MCP-Server (Model Context Protocol), der als API fÃ¼r die KI fungiert. Er lÃ¤uft parallel zum Dev-Server und Ã¼bersetzt Projekt-RealitÃ¤ten (DB-Schema, Tailwind-Config, CI-Status) in strukturierte Daten, die der Agent verlÃ¤sslich abrufen kann.2. Technische ArchitekturDer MCP-Server ist eine leichte TypeScript-Anwendung, die im Projekt-Root unter /mcp-server lebt.2.1 Live-Ressourcen (Context Provider)Der Agent kann diese URIs jederzeit lesen (read_resource), um sich zu orientieren. Er muss nicht mehr hunderte Dateien scannen.URIInhalt & ZweckQuelleproject://ui/tokensLiefert alle Tailwind-Farben, Spacings und Fonts als JSON. Verhindert, dass der Agent Farben erfindet ("Halluzinationen").tailwind.config.ts, globals.cssproject://db/schemaLiefert das aktuelle Datenbank-Schema (Tabellen, Relationen, Typen). Garantiert korrekte SQL/ORM-Queries.Supabase Introspection / schema.prisma / schema.keelproject://app/routesEine Karte aller existierenden Next.js Routen und API-Endpunkte. Verhindert Duplikate und tote Links.Scan von /app Ordnerstrukturproject://docs/activeKombiniert .cursorrules, project_specs.md und kritische Linter-Regeln zu einem Live-Regelwerk./docs + Linter Config2.2 Tools (Aktive Werkzeuge)Der Agent erhÃ¤lt deterministische Funktionen, um Aufgaben sicher zu erledigen.Tool NameFunktionvalidate_compliancePrÃ¼ft Code-Snippets gegen interne Regeln (z.B. "Sind Slugs deutsch?", "Sind Zod-Schemas synchron?").scaffold_featureErstellt standardisierte Ordnerstrukturen (MVC-Pattern) fÃ¼r neue Features, um Wildwuchs zu verhindern.query_db_readonlyErlaubt dem Agenten, sichere SELECT-Abfragen gegen die lokale DB zu fahren, um Datenstrukturen zu verifizieren (Sandbox-Mode).check_dependenciesPrÃ¼ft package.json auf Version-Konflikte oder SicherheitslÃ¼cken bevor neuer Code geschrieben wird.3. Implementierungs-Guide (Der "Builder Prompt")Kopiere diesen Prompt in deinen Agenten (Cursor Composer / Roo Code), um die Nexus Bridge fÃ¼r ein neues Projekt zu generieren.Markdown**Agiere als Senior System Architect.**
Erstelle die Infrastruktur fÃ¼r einen lokalen MCP-Server ("Nexus Bridge") in diesem Projekt.

**Ziel:** Der Server soll dir (dem Agenten) Live-Kontext Ã¼ber das Projekt liefern.

**Schritt 1: Setup**
1. Erstelle einen Ordner `/mcp-server`.
2. Initialisiere ein minimales TypeScript-Projekt (Node.js).
3. Installiere `@modelcontextprotocol/sdk` und `zod`.

**Schritt 2: Implementiere Resources (Read-Only)**
1. **Design System:** Schreibe einen Parser fÃ¼r `tailwind.config.ts`. Stelle die extrahierten Werte unter `project://ui/tokens` bereit.
2. **Database:** (Falls Prisma/Keel vorhanden): Lies die Schema-Datei ein und stelle sie unter `project://db/schema` bereit.
3. **File Map:** Erstelle einen rekursiven Scanner fÃ¼r den `/app` Ordner (ignoriere node_modules), der die Routing-Struktur unter `project://app/routes` bereitstellt.

**Schritt 3: Implementiere Tools (Executable)**
1. **Slug Validator:** Ein Tool `validate_slug(text: string)`, das prÃ¼ft, ob ein String URL-freundlich ist (lowercase, no umlauts, hyphens).
2. **Project Status:** Ein Tool `get_project_health()`, das die Ergebnisse von `npm run lint` und `npm run type-check` zusammenfasst und zurÃ¼ckgibt.

**Schritt 4: Integration**
Erstelle eine README im `/mcp-server` Ordner mit dem exakten JSON-Schnipsel, den der User in seine Cursor/Windsurf Einstellungen eintragen muss, um diesen Server zu aktivieren.

FÃ¼hre dies jetzt aus.
4. Konfiguration der IDE (User Action)Damit die BrÃ¼cke steht, muss der Server einmalig in der IDE registriert werden.FÃ¼r Cursor / Windsurf / Roo Code (settings.json oder Extension Config):JSON{
  "mcpServers": {
    "nexus-bridge": {
      "command": "node",
      "args": ["${workspaceFolder}/mcp-server/dist/index.js"],
      "env": {
        "NODE_ENV": "development",
        "DATABASE_URL": "postgresql://user:password@localhost:5432/db"
      },
      "disabled": false,
      "autoApprove": [
        "read_resource",
        "validate_compliance"
      ]
    }
  }
}
(Hinweis: autoApprove erlaubt dem Agenten, Lese-Zugriffe ohne nervige RÃ¼ckfragen durchzufÃ¼hren.)5. Der perfektionierte Workflow (Example Scenario)Mit dieser MCP-Erweiterung Ã¤ndert sich der Arbeitsablauf von "Raten" zu "Wissen":User Prompt: "Erstelle eine neue API Route fÃ¼r User-Settings."Agent (Nexus-Powered):Internal Thought: "Ich muss wissen, wie die User-Tabelle aussieht und welche Routen schon belegt sind."Action: Ruft project://db/schema ab. -> Erkennt: Tabelle heiÃŸt profiles, nicht users.Action: Ruft project://app/routes ab. -> Erkennt: /api/settings ist frei.Action: Ruft project://ui/tokens ab. -> WeiÃŸ: Fehler-Status ist Farbe destructive-500.Resultat: Der generierte Code passt beim ersten Versuch perfekt in die bestehende Architektur. Keine Import-Fehler, keine falschen Spaltennamen, keine Design-BrÃ¼che.
